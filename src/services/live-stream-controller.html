<link rel="import" href="../3rd-imports/scoped-imd.html">
<link rel="import" href="../3rd-imports/hls-js.html">
<link rel="import" href="../constants.html">

<script>
  IMD.define('live-stream-controller', ['constants', 'hls-js'], (constants, Hls) => {
    const {PLAY_STATES} = constants;

    class LiveStreamController {
      /**
       * Initializes a new LiveStreamController instance.
       * @param {StateManager} stateManager  The StateManager of the video player instance.
       * @return {LiveStreamController}  The new LiveStreamController instance.
       */
      constructor(stateManager) {
        this._stateManager = stateManager;
        this._clients = [];
      }

      /**
       * Registers a new HLS client to enable control of this live-stream.
       * @param  {Hls} client The HLS client that should be registered.
       * @return {void}
       */
      registerClient(client) {
        this._clients.push(client);

        client.on(Hls.Events.LEVEL_LOADED, (e, data) => this._handleLevelLoaded(client, data));
      }

      /**
       * Unregisters a new HLS client to stop control of this live-stream.
       * @param  {Hls} client The HLS client that should be unregistered.
       * @return {void}
       */
      unregisterClient(client) {
        this._clients = this._clients.filter(x => x !== client);

        client.off(Hls.Events.LEVEL_LOADED);
      }

      /**
       * Is called everytime the HLS client has finished loading a new level.
       * @param  {Hls} client The client that has loaded the level
       * @param  {LevelDetails} data An object containing level details retrieved after level playlist parsing.
       * @return {void}
       */
      _handleLevelLoaded(client, data) {
        let live = data.details.live;
        let oldLive = this._stateManager.state.live;
        this._stateManager.setLive(live);
        if(!live)
        {
          // Transition from live to not live indicates that the stream has ended
          if(oldLive) {
            this._stateManager.setPlayState(PLAY_STATES.FINISHED);
          }
          return;
        }

        let livePosition = client.liveSyncPosition;
        let totalDuration = data.details.totalduration;
        let fragmentDuration = data.details.targetduration;
        let hiddenAreaDuration = client.config.liveSyncDurationCount * fragmentDuration;
        if(!livePosition) {
          // Calculate fallback live position if liveSyncPosition is not set, yet.
          livePosition = Math.max(0, totalDuration - hiddenAreaDuration);
        }

        this._stateManager.setLivePosition(livePosition);
        this._stateManager.setLiveFragmentDuration(fragmentDuration);
        this._stateManager.setLiveDvr(data.details.fragments.length > client.config.liveSyncDurationCount);
      }
    }

    return LiveStreamController;
  });
</script>
