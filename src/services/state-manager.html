<script>
  const {extendObservable} = mobx;

  class StateManager {
    constructor() {
      extendObservable(this, {
        playState: 'PAUSED',
        position: 0,
        playbackRate: 1.0,
        volume: 1,
        muted: false,
        duration: 0,
        fullScreen: false
      })
    }

    static get PLAYBACK_RATES() {
      return [0.7, 1.0, 1.3, 1.5, 1.8, 2.0];
    }

    play() {
      this.playState = 'PLAYING';
    }

    pause() {
      this.playState = 'PAUSED';
    }

    togglePlayPause() {
      if(this.playState == 'PLAYING') {
        this.pause()
      } else {
        this.play();
      }
    }

    seek(seconds) {
      this.position = seconds;
    }

    setPlaybackRate(playbackRate) {
      this.playbackRate = playbackRate;
    }
    
    switchPlaybackRate() {
      let newIndex = (StateManager.PLAYBACK_RATES.indexOf(this.playbackRate) + 1) % StateManager.PLAYBACK_RATES.length;
      this.setPlaybackRate(StateManager.PLAYBACK_RATES[newIndex]);
    }

    toggleMute() {
      if(this.muted) {
        this.unmute()
      } else {
        this.mute();
      }
    }

    mute() {
        this.muted = true;
    }

    unmute() {
        this.muted = false;
    }

    toggleFullScreen(originatedFromUserEvent) {
      // This method is a little tricky because it can be called both because a
      // user initiated it through the ways our application provides and
      // because a user pressed 'Esc' during full screen mode. The latter
      // can't be intercepted by our application and can be only be detected
      // via an event listener on 'fullscreenchange'. This event will of course
      // also be fired when we switch to fullscreen from our application which is
      // why we have to take care of not changing our fullscreen value twice.
      let newFullScreenValue = !(document.fullScreen || document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement || document.fullscreenElement);
      // if this didn't originate from a keyboard event, then we'll still
      // get the old fullscreen value so we have to negate it
      if(!originatedFromUserEvent) {
        newFullScreenValue = !newFullScreenValue;
      }
      if(newFullScreenValue !== this.fullScreen) {
        this.fullScreen = !this.fullScreen;
      }
    }

    enterFullScreen() {
      this.fullScreen = true;
    }

    exitFullScreen() {
      this.fullScreen = false;
    }

    setVolume(volume) {
      // always unmute first to avoid potential inconsistent states between e.g. mute button icon and sound-control-bar
      this.unmute();
      if(volume >= 0 || volume <= 100) {
        this.volume = volume;
      }
    }

    setDuration(duration) {
      this.duration=duration;
    }
  }
</script>
