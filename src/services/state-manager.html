<script>
  define('state-manager', () => {
    class StateManager {
      /**
       * Initializes a new StateManager instance.
       * @param {VideoPlayer} videoPlayer  The VideoPlayer, whose state should be controlled.
       * @param {string} statePath  The path of the state property on the VideoPlayer.
       * @return {StateManager}  The new StateManager instance.
       */
      constructor(videoPlayer, statePath) {
        this.videoPlayer = videoPlayer;
        this.statePath = statePath;
      }

      /**
       * Contains the supported playback rates sorted ascending.
       * @type {number[]}
       */
      static get PLAYBACK_RATES() {
        return [0.7, 1.0, 1.3, 1.5, 1.8, 2.0];
      }

      /**
       * Contains the different play states.
       * @type {Object.<string, string>}
       */
      static get PLAY_STATES() {
        return {
          PLAYING: 'PLAYING',
          PAUSED: 'PAUSED',
        };
      }


      /**
       * Gets the state object of the attatched VideoPlayer.
       * @return {Object} The state object.
       */
      get state() {
        return this.videoPlayer[this.statePath];
      }

      /**
       * Sets a single property of the state.
       * @param {string} path  The state path of the property that shold be set.
       * @param {any} value The new value of the property.
       * @returns {void}
       */
      setState(path, value) {
        this.videoPlayer.set(this.statePath + '.' + path, value);
      }


      /**
       * Sets the play state to 'playing'.
       * @returns {void}
       */
      play() {
        this.setState('playState', StateManager.PLAY_STATES.PLAYING);
      }

      /**
       * Sets the play state to 'paused'.
       * @returns {void}
       */
      pause() {
        this.setState('playState', StateManager.PLAY_STATES.PAUSED);
      }

      /**
       * Toggles the current play state.
       * @returns {void}
       */
      togglePlayPause() {
        if(this.state.playState === StateManager.PLAY_STATES.PLAYING) {
          this.pause();
        } else {
          this.play();
        }
      }


      /**
       * Sets the current position in the video.
       * @param {number} seconds The current position in seconds.
       * @returns {void}
       */
      setPosition(seconds) {
        if(seconds < 0 || this.state.duration && seconds > this.state.duration) {
          throw new RangeError('Value must be between 0 and duration of the video.');
        }

        this.setState('position', seconds);
      }

      /**
       * Sets the duration of the video.
       * @param {number} seconds The duration of the current video in seconds.
       * @returns {void}
       */
      setDuration(seconds) {
        if(seconds < 0) {
          throw new RangeError('Value must be positive.');
        }

        this.setState('duration', seconds);
      }


      /**
       * Sets the playback rate of the video.
       * @param {number} playbackRate The new playback rate.
       * @returns {void}
       */
      setPlaybackRate(playbackRate) {
        if(!StateManager.PLAYBACK_RATES.includes(playbackRate)) {
          throw new RangeError(`Value must be in [${StateManager.PLAYBACK_RATES.toString()}].`);
        }

        this.setState('playbackRate', playbackRate);
      }

      /**
       * Switches playback rate in ascending order.
       * @returns {void}
       */
      switchPlaybackRate() {
        let newIndex = (StateManager.PLAYBACK_RATES.indexOf(this.state.playbackRate) + 1) % StateManager.PLAYBACK_RATES.length;
        this.setPlaybackRate(StateManager.PLAYBACK_RATES[newIndex]);
      }


      /**
       * Toggles the muting.
       * @returns {void}
       */
      toggleMute() {
        if(this.state.muted) {
          this.unmute();
        } else {
          this.mute();
        }
      }

      /**
       * Enables muting.
       * @returns {void}
       */
      mute() {
        this.setState('muted', true);
      }

      /**
       * Disables muting.
       * @returns {void}
       */
      unmute() {
        this.setState('muted', false);
      }

      /**
       * Sets the volume.
       * @param {number} volume The new volume (0.0-1.0).
       * @returns {void}
       */
      setVolume(volume) {
        if(!volume || volume < 0 || volume > 1) {
          throw new RangeError('Value must be between 0 and 1.');
        }

        // Always unmute first to avoid potential inconsistent states between
        // e.g. mute button icon and sound-control-bar
        this.unmute();
        this.setState('volume', volume);
      }


      /**
       * Toggles the full screen mode.
       * @returns {void}
       */
      toggleFullScreen() {
        this.setFullScreen(!this.state.fullScreen);
      }

      /**
       * Sets the full screen mode explicitly.
       * @param {boolean} fullScreen Boolean determining whether the full screen mode is active or not.
       * @returns {void}
       */
      setFullScreen(fullScreen) {
        this.setState('fullScreen', fullScreen);
      }

      /**
       * Toggles the visibility of the chapters overview.
       * @returns {void}
       */
      toggleDisplayChaptersOverview() {
        this.setState('displayChaptersOverview', !this.state.displayChaptersOverview);
      }
    }

    return StateManager;
  });
</script>
