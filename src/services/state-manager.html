<link rel='import' href='../constants.html'>

<script>
  define('state-manager', ['constants'], (constants) => {
    const {PLAY_STATES, PLAYBACK_RATES, QUALITY_MODES} = constants;

    class StateManager {
      /**
       * Initializes a new StateManager instance.
       * @param {VideoPlayer} videoPlayer  The VideoPlayer, whose state should be controlled.
       * @param {string} statePath  The path of the state property on the VideoPlayer.
       * @return {StateManager}  The new StateManager instance.
       */
      constructor(videoPlayer, statePath) {
        this.videoPlayer = videoPlayer;
        this.statePath = statePath;
      }


      /**
       * Gets the state object of the attatched VideoPlayer.
       * @return {Object} The state object.
       */
      get state() {
        return this.videoPlayer[this.statePath];
      }

      /**
       * Sets a single property of the state.
       * @param {string} path  [description]
       * @param {any} value [description]
       */
      setState(path, value) {
        this.videoPlayer.set(this.statePath + '.' + path, value);
      }


      /**
       * Sets the play state to 'playing'.
       */
      play() {
        this.setState('playState', PLAY_STATES.PLAYING);
      }

      /**
       * Sets the play state to 'paused'.
       */
      pause() {
        this.setState('playState', PLAY_STATES.PAUSED);
      }

      /**
       * Toggles the current play state.
       */
      togglePlayPause() {
        if(this.state.playState == PLAY_STATES.PLAYING) {
          this.pause()
        } else {
          this.play();
        }
      }


      /**
       * Sets the current position in the video.
       * @param {number} seconds The current position in seconds.
       */
      setPosition(seconds) {
        if(seconds < 0 || this.state.duration && seconds > this.state.duration) {
          throw new RangeError('Value must be between 0 and duration of the video.');
        }

        this.setState('position', seconds);
      }

      /**
       * Sets the duration of the video.
       * @param {number} seconds The duration of the current video in seconds.
       */
      setDuration(seconds) {
        if(seconds < 0) {
          throw new RangeError('Value must be positive.')
        }

        this.setState('duration', seconds);
      }


      /**
       * Sets the playback rate of the video.
       * @param {number} playbackRate The new playback rate.
       */
      setPlaybackRate(playbackRate) {
        if(!PLAYBACK_RATES.includes(playbackRate)) {
          throw new RangeError(`Value must be in [${PLAYBACK_RATES.toString()}].`)
        }

        this.setState('playbackRate', playbackRate);
      }

      /**
       * Switches playback rate in ascending order.
       */
      switchPlaybackRate() {
        let newIndex = (PLAYBACK_RATES.indexOf(this.state.playbackRate) + 1) % PLAYBACK_RATES.length;
        this.setPlaybackRate(PLAYBACK_RATES[newIndex]);
      }


      /**
       * Toggles the muting.
       */
      toggleMute() {
        if(this.state.muted) {
          this.unmute()
        } else {
          this.mute();
        }
      }

      /**
       * Enables muting.
       */
      mute() {
          this.setState('muted', true);
      }

      /**
       * Disables muting.
       */
      unmute() {
          this.setState('muted', false);
      }

      /**
       * Sets the volume.
       * @param {number} volume The new volume (0.0-1.0).
       */
      setVolume(volume) {
        if(!volume || volume < 0 || volume > 1) {
          throw new RangeError('Value must be between 0 and 1.')
        }

        // Always unmute first to avoid potential inconsistent states between
        // e.g. mute button icon and sound-control-bar
        this.unmute();
        this.setState('volume', volume);
      }


      /**
       * Sets the quality.
       * @param {string} quality The new quality.
       */
      setQuality(quality) {
        if(!Object.values(QUALITY_MODES).includes(quality)) {
          throw new RangeError(`Value must be in [${Object.values(QUALITY_MODES).toString()}].`)
        }

        this.setState('quality', quality);
      }


      /**
       * Toggles the full screen mode.
       */
      toggleFullScreen() {
        this.setFullScreen(!this.state.fullScreen);
      }

      /**
       * Sets the full screen mode explicitly.
       * @param {boolean} fullScreen Boolean determining whether the full screen mode is active or not.
       */
      setFullScreen(fullScreen) {
        this.setState('fullScreen', fullScreen);
      }
    }

    return StateManager;
  });
</script>
