<link rel="import" href="../../bower_components/imd/imd.html">

<link rel="import" href="../base-element.html">

<dom-module id="resizer-control">
  <template>
    <style type="text/css">
      /*
      * The nested flex boxes are unfortunately neccessary to avoid Safaris 100% height bug
      */
      :host {
        display: flex;
        z-index: 2;
        visibility: hidden;
      }
      #container__resizer_control {
        display: flex;
        overflow: hidden;
      }
      #resizer {
        border: 2px solid black;
        cursor: ew-resize;
        height: inherit;
      }
    </style>

    <div id="container__resizer_control">
      <div
        id="resizer"
        draggable="true"
        on-dragstart="handleDragStart"
        on-drag="resizeVideos"
        on-dragend="handleDragEnd">
      </div>
    </div>
  </template>

  <script>
    define('resizer-control', ['base-element'], (BaseElement) => {
      class ResizerControl extends BaseElement {
        static get is() { return 'resizer-control'; }

        static get properties() {
          return {
            globalFlexBasisGap: {
              type: Array,
              value: () => [0, 0],
            },
            videos: Array,
            mousePositionX: Number,
          };
        }

        handleDragStart(e) {
          // Neccessary for FF to handle Drag'n'Drop
          // Since FF does not support the mouse position within a drag event, it has to be handled with the dragover event
          e.dataTransfer.setData('text', '');
          this.parentElement.addEventListener('dragover', this.handleDragOver.bind(this));

          // Get videos to resize
          this.videos = [this.findPreviousVideo(), this.findNextVideo()];

          // Avoid a dragging ghost image by creating a new element which shall be shown
          // but is hidden per default. Unfortunately this is the only way to do so.
          let dragImage = this.cloneNode(true);
          dragImage.style.visibility = 'hidden';
          document.body.appendChild(dragImage);
          // If we want to hide the ghost image in fullscreen mode, we have to
          // move it completely out of view by setting its position as -10000|-10000
          e.dataTransfer.setDragImage(dragImage, -10000, -10000);
        }

        handleDragEnd() {
          // Remove the created ghost element & eventhandler when the dragging ended.
          document.body.removeChild(document.body.lastChild);
          this.parentElement.removeEventListener('dragover', this.handleDragOver.bind(this));
        }

        handleDragOver(e) {
          this.mousePositionX = e.pageX;
        }

        resizeVideos(e) {
          let resizerPositionX = (e.originalTarget || e.srcElement).offsetLeft;
          let direction = this.getMouseDirection(e, resizerPositionX);
          // MaxGap defines the maximal value by which a videos can be increased or decreased.
          // Since we change both videos at the same time the number has to be halved.
          let maxGap = (this.parentElement.offsetWidth * 0.49) / 2;
          let factor = Math.abs(this.mousePositionX - resizerPositionX);

          /*
          * The resizing consists of two parts: One video is increased, while the other one os decreased by the same factor.
          * This is neccessary to keep these two videos in a row. If only one video is decreased it may be elem videos from the belower row
          * will shift up.
          */
          if(direction === 'left') {
            if(this.globalFlexBasisGap[1] < maxGap) {
              this.changeFlexBasis(this.videos[1], factor, 1, maxGap);
              this.changeFlexBasis(this.videos[0], -factor, 0, maxGap);
            }
          } else if(direction === 'right') {
            if(this.globalFlexBasisGap[0] < maxGap) {
              this.changeFlexBasis(this.videos[1], -factor, 1, maxGap);
              this.changeFlexBasis(this.videos[0], factor, 0, maxGap);
            }
          }
        }

        findNextVideo() {
          // Iterate forward through the DOM until the first video element is found
          let elem = this; // eslint-disable-line consistent-this
          while (elem.nodeName !== 'VIDEO-STREAM') {
            elem = elem.nextElementSibling;
          }
          return elem;
        }

        findPreviousVideo() {
          // Iterate backward through the DOM until the first video element is found
          let elem = this; // eslint-disable-line consistent-this
          while (elem.nodeName !== 'VIDEO-STREAM') {
            elem = elem.previousElementSibling;
          }
          return elem;
        }

        getMouseDirection(e, resizerPositionX) {
          // This handles the special case when ending the drag,
          // where e.pageX is 0
          if(this.mousePositionX === 0) {
            return '';
          }

          if (this.mousePositionX < resizerPositionX) {
            return 'left';
          } else if (this.mousePositionX > resizerPositionX) {
            return 'right';
          }
        }

        changeFlexBasis(video, factor, index, maxGap) {
          let oldValue = this.globalFlexBasisGap[index];

          // The new value is not allowed to be greater than the maximal gap
          let newValue = oldValue + factor;
          newValue = newValue <= - maxGap ? (- maxGap) : newValue;
          newValue = newValue >= maxGap ? maxGap : newValue;

          this.globalFlexBasisGap[index] = newValue;
          video.style.flexBasis = 'calc(49% + ' + newValue + 'px)';
        }
      }

      window.customElements.define(ResizerControl.is, ResizerControl);
    });
  </script>

</dom-module>
