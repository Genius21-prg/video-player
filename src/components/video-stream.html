<link rel="import" href="../../bower_components/imd/imd.html">

<link rel="import" href="../constants.html">
<link rel="import" href="../base-element.html">
<link rel="import" href="../3rd-imports/hls-js.html">


<dom-module id="video-stream">
  <template>
    <style type="text/css">
      #container__video_stream {
        position: relative;
        width: 100%;
        height: 100%;
      }
      video {
        width: inherit;
        height: inherit;
      }
      ::cue{
        visibility: hidden;
      }

      #container__poster_overlay {
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
      }

      #image__poster {
        width: 100%;
        height: 100%;
      }
    </style>

    <div id="container__video_stream">
      <video
        id="video"
        preload="[[ifThenElse(preload, 'auto', 'metadata')]]"
        on-click="handleClick"
        on-canplay="handleCanPlay"
        on-playing="handlePlaying"
        on-ended="handleEnded"
        on-loadedmetadata="handleLoadedMetadata"
        on-timeupdate="handleTimeUpdate">
        <template is="dom-repeat" items="{{captions}}">
          <track src="[[item.source]]" kind="subtitles" srclang="[[item.language]]" label="English">
        </template>
      </video>
      <template is="dom-if" if="{{and(urls.poster, isPosterVisible)}}">
        <div id="container__poster_overlay">
          <img id="image__poster" src="[[urls.poster]]" alt="Poster" />
        </div>
      </template>
    </div>
  </template>

  <script>
    define('video-stream', ['base-element', 'hls-js', 'constants'], (BaseElement, Hls, constants) => {
      const {PLAY_STATES, QUALITY_MODES, HLS_MIME_TYPE, SYNC_DIFF_THRESHOLD} = constants;

      class VideoStream extends BaseElement {
        static get is() { return 'video-stream'; }

        static get properties() {
          return {
            state: Object,
            stateManager: Object,
            synchronizationManager: Object,
            captions: {
              type: Object,
              value: () => ({})
            },
            urls: Object,
            preload: {
              type: Boolean,
              value: true,
            },
            master: {
              type: Boolean,
              value: true,
            },
            qualityUrl: String,
            initializingVideo: {
              type: Boolean,
              value: true,
            },
            isPosterVisible: {
              type: Boolean,
              value: true,
            },
            hlsClient: Object,
            nativeHlsSupport: {
              type: Boolean,
              readOnly: true,
              computed: '_nativeHlsSupport()',
            },
          };
        }

        static get observers() {
          return [
            'playStateChanged(state.playState)',
            'positionChanged(state.position)',
            'playbackRateChanged(state.playbackRate)',
            'volumeChanged(state.volume)',
            'mutedChanged(state.muted)',
            'setCaptionLanguage(state.selectedCaption)',
            'qualityChanged(urls, state.quality)',
          ];
        }

        _nativeHlsSupport() {
          return this.$.video.canPlayType(HLS_MIME_TYPE) !== '';
        }

        connectedCallback() {
          super.connectedCallback();
          this.synchronizationManager.registerVideo(this.$.video);
        }

        disconnectedCallback() {
          super.disconnectedCallback();
          this.synchronizationManager.unregisterVideo(this.$.video);
        }

        handleTimeUpdate() {
          if(this.master && !this.initializingVideo) {
            this.stateManager.setPosition(this.$.video.currentTime);
          }
        }

        handleLoadedMetadata() {
          // Extract duration of the video after metadata have been loaded
          if(this.master) {
            this.stateManager.setDuration(this.$.video.duration);
          }
        }

        handleCanPlay() {
          if(this.initializingVideo) {
            this.applyState();
            this.initializingVideo = false;
          }
        }

        handlePlaying() {
          this.isPosterVisible = false;
        }

        handleEnded() {
          // Sometimes the position does not equals the duration if the video
          // has ended. To fix this issue, the position is set manually.
          this.stateManager.setPosition(this.state.duration);
        }

        handleClick() {
          this.stateManager.togglePlayPause();
        }

        applyState() {
          this.playStateChanged(this.state.playState);
          this.positionChanged(this.state.position);
          this.playbackRateChanged(this.state.playbackRate);
          this.volumeChanged(this.state.volume);
          this.mutedChanged(this.state.muted);
        }

        playStateChanged(playState) {
          if (playState === PLAY_STATES.PLAYING) {
            this.$.video.play();
          } else if (playState === PLAY_STATES.PAUSED) {
            this.$.video.pause();
          }
        }

        positionChanged(position) {
          if(Math.abs(this.$.video.currentTime - position) > SYNC_DIFF_THRESHOLD) {
            this.$.video.currentTime = position;
          }
        }

        playbackRateChanged(playbackRate) {
          this.$.video.playbackRate = playbackRate;
        }

        volumeChanged(volume) {
          this.$.video.volume = volume;
        }

        mutedChanged(muted) {
          this.$.video.muted = muted;
        }

        setCaptionLanguage(language){
          Polymer.RenderStatus.afterNextRender(this, function() {
            if( (this.master) && (this.captions)){
              for (var textTrackElement in this.$.video.textTracks){
                var trackObject = this.$.video.textTracks[textTrackElement];
                if( trackObject && trackObject.language && trackObject.language.match(language)) {
                  trackObject.mode = "showing";
                  this.stateManager.setCurrentCaptionCue(trackObject.activeCues[0]);
                  self = this;
                  // Subscribe to cue changes as defined in the WebVTT API:
                  // https://developer.mozilla.org/en-US/docs/Web/API/WebVTT_API
                  trackObject.oncuechange = function (){
                    self.stateManager.setCurrentCaptionCue(this.activeCues[0]);
                  }
                }
                else if (trackObject && trackObject.language) {
                  trackObject.mode = "hidden";
                }
              }
            }
          });
        }

        qualityChanged(urls, quality) {
          let url = urls[quality];
          this.initializingVideo = true;

          // Change source depending on quality
          if(this.nativeHlsSupport || quality !== QUALITY_MODES.HLS) {
            // Destroy old hls client
            if(this.hlsClient) {
              this.hlsClient.destroy();
            }

            // The src attribute can not be updated using data bindings
            // since the binding may be overwritten by hls.js
            this.$.video.setAttribute('src', url);
          } else {
            // Create and configure new hls client for existing video element
            this.hlsClient = new Hls();
            this.hlsClient.loadSource(url);
            this.hlsClient.attachMedia(this.$.video);
          }
        }
      }

      window.customElements.define(VideoStream.is, VideoStream);
    });
  </script>

</dom-module>
