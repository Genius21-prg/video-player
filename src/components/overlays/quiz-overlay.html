<link rel="import" href="../../3rd-imports/scoped-imd.html">

<link rel="import" href="../../mixins/binding-helpers.html">
<link rel="import" href="../../mixins/ioc-requester.html">
<link rel="import" href="../../mixins/localization.html">

<link rel="import" href="../../styling/overlay--style-module.html">

<dom-module id="quiz-overlay">
  <template>
    <style type="text/css" include="overlay--style-module">
      #container__quiz-overlay {
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        background-color: rgba(0, 0, 0, 0.85);
        color: white;
      }

      .container__centered-row input {
        margin: 0 !important;
      }

      .text__quiz-answer {
        padding-left: 10px;
      }

      .container__centered-row {
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: row;
      }

      .button__quiz {
        margin-top: 10px;
        text-decoration: none;
        color: white;
      }

      .quiz__highlighting-correct {
        color: green;
      }

      .quiz__highlighting-wrong {
        color: red;
      }

      .quiz__highlighting-strikethrough {
        text-decoration: line-through
      }

    </style>

    <div id="container__quiz-overlay" class="overlay" style$="visibility: [[ifThenElse(_isVisible, 'visible', 'hidden')]];">
      <h3 id="text__quiz-question">[[_currentQuestion.text]]</h3>

      <template is="dom-if" if="[[_isTextQuestion(_currentQuestion)]]">
        <div class$="[[_getValidationClass(_currentQuestion, _correctAnswersShown, _correctAnswers, _isAnswerCorrect, null)]]">
          <input id="input__freetext-answer" type="text"></input>
        </div>

        <template is="dom-if" if="[[_correctAnswersShown]]">
          <h5>[[localize('quiz--correct-answers')]]</h5>
          <template is="dom-repeat" items="[[_correctAnswers]]">
            <span class="">[[item.text]]</span>
          </template>
        </template>
      </template>

      <template is="dom-repeat" items="[[_currentQuestion.answers]]">
        <div class$="[[_getValidationClass(_currentQuestion, _correctAnswersShown, _correctAnswers, _isAnswerCorrect, item)]]">
          <div class="container__centered-row">
            <input name="answer" class="select__quiz-answer" value$="[[item.id]]" id="select__quiz-answer-[[item.id]]" type$="[[ifThenElse(_isSingleChoiceQuestion, 'radio', 'checkbox')]]"></input>
            <span class="text__quiz-answer">[[item.text]]</span>
          </div>
        </div>
      </template>

      <div class="container__centered-row">
        <template is="dom-if" if="[[_correctAnswersShown]]">
          <a class="button button__quiz" on-click="_handleCancelClick" href="#">[[localize('general--continue')]]</a>
        </template>

        <template is="dom-if" if="[[!_correctAnswersShown]]">
          <a class="button button__quiz" on-click="_handleCancelClick" href="#">[[localize('general--cancel')]]</a>
          <a class="button button__quiz" on-click="_handleSubmitClick" href="#">[[localize('quiz--submit')]]</a>
        </template>
      </div>
    </div>
  </template>

  <script>
    IMD.define('quiz-overlay', ['binding-helpers', 'ioc-requester', 'localization', 'constants'], (BindingHelpersMixin, IocRequesterMixin, LocalizationMixin, constants) => {
      const {PLAY_STATES} = constants;

      class QuizOverlay extends BindingHelpersMixin(IocRequesterMixin(LocalizationMixin(Polymer.Element))) {
        static get is() { return 'quiz-overlay'; }

        static get properties() {
          return {
            state: Object,
            questions: Array,
            callback: Object,

            _currentQuestions: {  // questions that should be shown in the current playback second (could be more than one)
              type: Array,
              value: [],
            },

            _currentQuestion: {  // the first question that has to be shown in the current second. Used for displaying the overlay. Should probably be computed, that didn't work though
              type: Object,
              value: null,
            },

            _lastProcessedPosition: {  // The last playback position second that questions where added to currentQuestions for
              type: Number,
              value: 0,
            },

            _correctAnswersShown: {  // could probably be computed from _correctAnswers too
              type: Boolean,
              value: false,
            },

            _correctAnswers: {
              type: Array,
              value: [],
            },

            _isAnswerCorrect: Boolean,

            _stateManager: {
              type: Object,
              inject: 'StateManager',
            },

            _isEnabled: {
              type: Boolean,
              value: true,
            },

            _isVisible: {
              type: Boolean,
              computed: '_getIsVisible(_isEnabled, _currentQuestion)',
            },

            _isSingleChoiceQuestion: {
              type: Boolean,
              computed: '_getIsSingleChoiceQuestion(_currentQuestion)',
            },
          };
        }

        static get observers() {
          return [
            '_playStateChanged(state.playState)',
            '_positionChanged(state.position, state.duration)',
          ];
        }

        _isTextQuestion(question) {
          return question != null && question.type == 'freetext';
        }

        _getIsSingleChoiceQuestion(question) {
          return question != null && question.type == 'single-choice';
        }

        _getIsVisible(enabled, currentQuestion) {
          return enabled && currentQuestion != null;
        }

        _playStateChanged(playState) {
          if(playState === PLAY_STATES.PAUSED || playState === PLAY_STATES.WAITING)
            return;

          this._currentQuestions = [];
          this._setCurrentQuestion();
        }

        _positionChanged(position, duration) {
          let flooredPosition = Math.floor(position);

          if(flooredPosition <= this._lastProcessedPosition) {
            return;
          }

          this._addCurrentQuestionsForPosition(flooredPosition);
          this._lastProcessedPosition = flooredPosition;

          if(this._isVisible) {
            this._stateManager.pause();
          }
        }

        _setCurrentQuestion() {
          if(this._currentQuestions.length > 0) {
            this._currentQuestion = this._currentQuestions[0];
          }
          else {
            this._currentQuestion = null;
          }
        }

        _addCurrentQuestionsForPosition(position) {
          let index = 0;
          for(index = 0; index < this.questions.length; ++index) {
            if(this.questions[index].position == position) {
              this.push('_currentQuestions', this.questions[index]);
            }
          }

          this._setCurrentQuestion();
        }

        _dismissCurrentQuestion() {
          this._correctAnswersShown = false;
          this.shift('_currentQuestions');
          this._setCurrentQuestion();

          if(this._currentQuestion == null) {
            this._stateManager.play();
          }
        }

        _getValidationClass(currentQuestion, correctAnswersShown, correctAnswers, isAnswerCorrect, answer) {
          var correct = false;
          var selected = false;

          if(!correctAnswersShown)
            return '';

          if(currentQuestion.type == 'freetext') {
            correct = isAnswerCorrect;
          }
          else {
            selected = this.shadowRoot.querySelector('#select__quiz-answer-' + answer.id).checked;

            var shouldBeSelected = false;
            for(var index = 0; index < correctAnswers.length; ++index) {
              if(correctAnswers[index].id == answer.id) {
                shouldBeSelected = true;
                break;
              }
            }

            if(selected && shouldBeSelected || !selected && !shouldBeSelected) {
              correct = true;
            }
          }

          if(correct)
            return 'quiz__highlighting-correct';

          if(selected)
            return 'quiz__highlighting-wrong quiz__highlighting-strikethrough';

          return 'quiz__highlighting-wrong';
        }

        _submitCurrentQuestion() {
          var callback = window[this.callback];

          if(this._isTextQuestion()) {
            let retval = callback(this._currentQuestion, document.getElementById("input__freetext-answer").value);

            this._correctAnswers = retval.correctAnswers;
            this._isAnswerCorrect = retval.isAnswerCorrect;
          } else { // single or multiple choice question
            let retval = callback(this._currentQuestion, this._getSelectedAnswers());

            this._correctAnswers = retval.correctAnswers;
            this._isAnswerCorrect = retval.isAnswerCorrect;
          }

          this._correctAnswersShown = true;
        }

        _getSelectedAnswers() {
          var ids = []
          var result = [];

          let inputs = document.getElementsByClassName("select__quiz-answer");
          for(let index = 0; index < inputs.length; ++index) {
            if(inputs[index].checked) {
              let answerid = inputs[index].id.split("-").slice(-1)[0];
              ids.push(parseInt(answerid));
            }
          }

          return this._currentQuestion.answers.filter(function(answer) {
            return ids.includes(answer.id);
          });
        }

        _handleCancelClick(e) {
          this._dismissCurrentQuestion();
          e.preventDefault();
        }

        _handleSubmitClick(e) {
          this._submitCurrentQuestion();
          e.preventDefault();
        }
      }

      window.customElements.define(QuizOverlay.is, QuizOverlay);
    });
  </script>

</dom-module>
