<link rel="import" href="../../3rd-imports/scoped-imd.html">

<link rel="import" href="../../mixins/binding-helpers.html">
<link rel="import" href="../../mixins/ioc-requester.html">
<link rel="import" href="../../mixins/localization.html">

<link rel="import" href="../../styling/overlay--style-module.html">

<dom-module id="quiz-overlay">
  <template>
    <style type="text/css" include="overlay--style-module">
    </style>

    <div id="container__quiz-overlay" class="overlay" style$="visibility: [[ifThenElse(_isVisible, 'visible', 'hidden')]];">
      <div id="container__quiz-question-text">
        <span id="text__quiz-question">[[_currentQuestion.title]]</span>
      </div>

      <template is="dom-if" if=[[_isTextQuestion(_currentQuestion)]]">
        <input type="text"></input>
      </template>

      <template is="dom-repeat" items="[[_currentQuestion.answers]]">
        <input type="[[ifThenElse(_isSingleChoiceQuestion(_currentQuestion), 'radio', 'checkbox']]"></input>
        <span>[[item.text]]</span>
      </template>

      <a id="button__hide_question" class="button" on-click="_handleCancelClick" href="#">[[localize('general--cancel')]]</a>
      <a id="button__submit_question" class="button" on-click="_submitCurrentQuestion" href="#">[[localize('general--ok')]]</a>
    </div>
  </template>

  <script>
    IMD.define('quiz-overlay', ['binding-helpers', 'ioc-requester', 'localization', 'constants'], (BindingHelpersMixin, IocRequesterMixin, LocalizationMixin, constants) => {
      const {PLAY_STATES} = constants;

      class QuizOverlay extends BindingHelpersMixin(IocRequesterMixin(LocalizationMixin(Polymer.Element))) {
        static get is() { return 'quiz-overlay'; }

        static get properties() {
          return {
            state: Object,
            questions: Array,

            _currentQuestions: {  // questions that should be shown in the current playback second (could be more than one)
              type: Array,
              value: [],
            },

            _currentQuestion: {  // the first question that has to be shown in the current second. Used for displaying the overlay. Should probably be computed, that didn't work though
              type: Object,
              value: null,
            },

            _lastProcessedPosition: {  // The last playback position second that questions where added to currentQuestions for
              type: Number,
              value: 0,
            },

            _validationCallback: {
              type: Object,
              value: null,
            },

            _stateManager: {
              type: Object,
              inject: 'StateManager',
            },

            _isEnabled: {
              type: Boolean,
              value: true,
            },

            _isVisible: {
              type: Boolean,
              computed: '_getIsVisible(_isEnabled, _currentQuestion)',
            },
          };
        }

        static get observers() {
          return [
            '_playStateChanged(state.playState)',
            '_positionChanged(state.position, state.duration)',
          ];
        }

        setQuizValidationCallback(validationCallback) {
          _validationCallback = validationCallback;
        }


        _isSingleChoiceQuestion(question) {
          return question != null && question.type == 'single_choice';
        }

        _isTextQuestion(question) {
          return question != null && question.type == 'freetext';
        }

        _getIsVisible(enabled, currentQuestion) {
          return enabled && currentQuestion != null;
        }

        _playStateChanged(playState) {
          if(playState === PLAY_STATES.PAUSED || playState === PLAY_STATES.WAITING)
            return;

          this._currentQuestions = [];
          this._setCurrentQuestion();
        }

        _positionChanged(position, duration) {
          let flooredPosition = Math.floor(position);

          if(flooredPosition <= this._lastProcessedPosition) {
            return;
          }

          this._addCurrentQuestionsForPosition(flooredPosition);
          this._lastProcessedPosition = flooredPosition;

          if(this._isVisible) {
            this._stateManager.pause();
          }
        }

        _setCurrentQuestion() {
          if(this._currentQuestions.length > 0) {
            this._currentQuestion = this._currentQuestions[0];
          }
          else {
            this._currentQuestion = null;
          }
        };

        _addCurrentQuestionsForPosition(position) {
          let index = 0;
          for(index = 0; index < this.questions.length; ++index) {
            if(this.questions[index].position == position) {
              this.push('_currentQuestions', this.questions[index]);
            }
          }

          this._setCurrentQuestion();
        }

        _dismissCurrentQuestion() {
          this.shift('_currentQuestions');
          this._setCurrentQuestion();

          if(this._currentQuestion == null) {
            this._stateManager.play();
          }
        }

        _handleCancelClick(e) {
          this._dismissCurrentQuestion();
          e.preventDefault();
        }
      }

      window.customElements.define(QuizOverlay.is, QuizOverlay);
    });
  </script>

</dom-module>
