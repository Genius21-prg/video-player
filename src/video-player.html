<link rel="import" href="../bower_components/imd/imd.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-repeat.html">

<link rel="import" href="3rd-imports/hls-js.html">
<link rel="import" href="base-element.html">
<link rel="import" href="3rd-imports/font-awesome.html">
<link rel="import" href="services/state-manager.html">
<link rel="import" href="services/fullscreen-manager.html">
<link rel="import" href="components/video-stream.html">
<link rel="import" href="components/chapter-list.html">
<link rel="import" href="components/control-bar/control-bar.html">
<link rel="import" href="components/resizer-control.html">

<dom-module id="video-player">
  <template>
    <style type="text/css">
      :host {
        display: inline-block;
      }

      /* For some reason, just chaining those fullscreen selectors into one big
         selector doesn't work so we're stupid-duplicating all the rules. */
      #video-player-container:-webkit-full-screen #streams-container{
        display: flex;
        align-items: center;
      }
      #video-player-container:-moz-full-screen #streams-container{
        display: flex;
        align-items: center;
      }
      #video-player-container:-ms-fullscreen #streams-container{
        display: flex;
        align-items: center;
      }

      #video-player-container {
        height: 100%;
      }
      #streams-container {
        display: flex;
        flex-wrap: wrap;
        overflow: hidden;
        /* Cancel out the control bar height */
        height: calc(100% - 45px);
      }
      .video-stream {
        /* 49 to leave a bit space for the resizer */
        flex: 1 1 49%;
      }
    </style>

    <div id="video-player-container">
      <div id="streams-container">
        <template is="dom-repeat" items="{{configuration.streams}}">
          <video-stream
            state="{{state}}"
            state-manager="{{stateManager}}"
            urls="{{item}}"
            preload="{{configuration.videoPreload}}"
            master="{{equals(index, 0)}}"
            class="video-stream"
            style$="height: calc(100% / {{rowCount(configuration.streams)}});">
          </video-stream>
          <template is="dom-if" if="{{needResizer(index, configuration.streams.length)}}">
            <resizer-control style$="visibility: [[ifThenElse(needResizerShown, 'visible', 'hidden')]]"></resizer-control>
          </template>
        </template>
      </div>
      <control-bar
        state="{{state}}"
        state-manager="{{stateManager}}"
        has-chapters="{{hasChapters}}"
        available-qualities="{{availableQualities}}">
      </control-bar>
      <template is="dom-if" if="{{state.isChapterListShown}}">
        <chapter-list
          state="{{state}}"
          state-manager="{{stateManager}}"
          chapters="{{configuration.chapters}}">
        </chapter-list>
      </template>
    </div>
  </template>

  <script>
    define(['base-element', 'state-manager', 'fullscreen-manager', 'hls-js', 'constants'], (BaseElement, StateManager, FullscreenManager, Hls, constants) => {
      const {DEFAULT_STATE, DEFAULT_CONFIGURATION, PLAY_STATES, QUALITY_MODES, PLAYING_EVENT_NAME} = constants;

      class VideoPlayer extends BaseElement {
        static get is() { return 'video-player'; }

        // A function is used to determine default values of properties to
        // ensure that each element gets its own copy of the value, rather than
        // having an object or array shared across all instances of the element.
        static get properties() {
          return {
            configuration: {
              type: Object,
              value: () => ({}),
            },
            state: {
              type: Object,
              value: () => ({}),
            },
            stateManager: Object,
            fullscreenManager: Object,
            needResizerShown: {
              type: Boolean,
              value: false,
            },
            availableQualities: {
              type: Array,
              computed: '_availableQualities(configuration.streams)',
            },
            hasChapters: {
              type: Boolean,
              computed: '_hasChapters(configuration.chapters)',
            },
          };
        }

        static get observers() {
          return [
            'configurationChanged(configuration)',
            'availableQualitiesChanged(availableQualities, stateManager)',
            'primaryColorChanged(configuration.primaryColor)',
            'secondaryColorChanged(configuration.secondaryColor)',
            'backgroundColorForPrimaryChanged(configuration.backgroundColorForPrimary)',
            'playStateChanged(state.playState)',
            'fullscreenChanged(state.fullscreen)',
          ];
        }

        _availableQualities(streams) {
          if (streams) {
            let supportedQualities = Object.values(QUALITY_MODES);
            if(!Hls.isSupported()) {
              supportedQualities = supportedQualities.filter(quality => quality !== QUALITY_MODES.HLS);
            }

            return supportedQualities
                     .filter(quality => streams.every(stream => Object.keys(stream)
                                                                      .includes(quality)));
          }
        }

        _hasChapters() {
          return this.configuration && this.configuration.chapters && this.configuration.chapters.length !== 0;
        }

        ready() {
          super.ready();

          // Build state from provided intial state configuration and default values
          this.state = Object.assign({}, DEFAULT_STATE, this.state, this.configuration.initialState);

          // Initialize StateManager
          this.stateManager = new StateManager(this, 'state');

          // Initialize FullscreenManager
          this.fullscreenManager = new FullscreenManager(this.$['video-player-container']);
          this.fullscreenManager.onFullscreenChanged((fullscreen) => {
            this.stateManager.setFullscreen(fullscreen);
          });

          // Add event handlers for mouse events to show/hide resizer
          this.$['streams-container'].addEventListener('mouseenter', () => this.needResizerShown = true);
          this.$['streams-container'].addEventListener('mouseleave', () => this.needResizerShown = false);

          // Listen for events from other instances to pause playback when
          // another instance starts playing
          window.addEventListener(PLAYING_EVENT_NAME, (e) => {
            if(e.detail && e.detail.sender !== this) {
              this.stateManager.pause();
            }
          });
        }

        reloadConfiguration() {
          // Clone configuration to reevaluate all observers
          this.configuration = Object.assign({}, this.configuration);
        }

        configurationChanged(configuration) {
          // Fill missing properties in provided configuration with default values
          if(Object.keys(DEFAULT_CONFIGURATION).filter(x => !Object.keys(configuration).includes(x)).length > 0) {
            this.configuration = Object.assign({}, DEFAULT_CONFIGURATION, configuration);
          }
        }

        availableQualitiesChanged(availableQualities) {
          // If not all streams are available in the specified quality, use default one that is available for all streams
          if(this.stateManager && !availableQualities.includes(this.state.quality)) {
            let defaultQuality = Object.values(QUALITY_MODES)
                                       .find(quality => availableQualities.includes(quality));
            this.stateManager.setQuality(defaultQuality);
          }
        }

        playStateChanged(playState) {
          // Dispatch event if video is playing to stop playback on other instances
          if(playState === PLAY_STATES.PLAYING) {
            let event = new CustomEvent(PLAYING_EVENT_NAME, {
              detail: {
                sender: this,
              },
            });

            window.dispatchEvent(event);
          }
        }

        fullscreenChanged(fullscreen) {
          if(this.fullscreenManager) {
            if (fullscreen) {
              this.fullscreenManager.enterFullscreen();
            } else {
              this.fullscreenManager.exitFullscreen();
            }
          }
        }

        // Since Firefox does not support WebComponents and shadow DOMs, it is not possible to set this in the CSS part.
        // The poperties are not correctly evaluated and thus the variable not set.
        primaryColorChanged(primaryColor) {
          this.style.setProperty('--primary-color', primaryColor);
        }
        secondaryColorChanged(secondaryColor) {
          this.style.setProperty('--secondary-color', secondaryColor);
        }
        backgroundColorForPrimaryChanged(backgroundColorForPrimary) {
          this.style.setProperty('--background-color-for-primary', backgroundColorForPrimary);
        }

        needResizer(index, length) {
          // Do not show the resizer when there is no second video to resize
          return (index % 2 === 0) && (index !== length - 1);
        }

        rowCount(streams) {
          return Math.ceil(streams.length / 2);
        }
      }

      window.customElements.define(VideoPlayer.is, VideoPlayer);
    });
  </script>
</dom-module>
