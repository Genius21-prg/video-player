<link rel='import' href='../../polymer/polymer-element.html'>
<link rel='import' href='../../polymer/lib/elements/dom-repeat.html'>
<link rel='import' href='3rd-imports/mobx.html'>
<link rel='import' href='3rd-imports/font-awesome.html'>

<link rel='import' href='services/state-manager.html'>
<link rel='import' href='components/video-stream.html'>
<link rel='import' href='components/control-bar/user-controls.html'>
<link rel='import' href='components/chapters-overview.html'>


<dom-module id='video-player'>
  <template>
    <div id='streams-container'>
      <template is='dom-repeat' items='{{streams}}'>
        <video-stream state-manager='{{stateManager}}' url='{{item}}' master='{{equals(index, 0)}}'></video-stream>
      </template>
    </div>
    <user-controls state-manager='{{stateManager}}'></user-controls>
    <chapters-overview class="invisible" state-manager='{{stateManager}}' outline='{{outline}}'></chapters-overview>
  </template>

  <script>
    (function() {
      const {reaction} = mobx;

      class VideoPlayer extends Polymer.Element {
        static get is() { return 'video-player'; }

        static get properties() {
          return {
            streams: {
              type: Array,
              value: []
            },
            outline: {
                type: Object,
                value: {
                    outlines: []
                }
            },
            stateManager: {
              type: Object,
              readOnly: true,
              value: new StateManager(),
              observer: '_updateStateBindings'
            }
          };
        }

        ready() {
          super.ready();
          // When possible, use afterNextRender to defer non-critical
          // work until after first paint.
          Polymer.RenderStatus.afterNextRender(this, function() {
            this.stateManager.pause();
            this.stateManager.seek(0);
            this.stateManager.toggleMute(); //just for testing
            this.stateManager.setVolume(75);
            //this.stateManager.playbackRate = 2;
          });
        }

        equals(a, b) {
          return a === b;
        }

        // functions that are called when the state of the stateManagers properties change
        _updateStateBindings() {
          // Dispose old reactions
          if(this.reactionDisposers) {
            this.reactionDisposers.forEach(disposer => disposer());
          }
          // Register new reactions
          this.reactionDisposers = [
            reaction(() => this.stateManager.displayChaptersOverview, this._displayChaptersOverviewChanged.bind(this))
          ];
        }

        _displayChaptersOverviewChanged(displayState) {
          let chaptersOverview = this.shadowRoot.querySelector('chapters-overview');
          if (displayState) {
            chaptersOverview.classList.remove('invisible');
          }
          else {
            chaptersOverview.classList.add('invisible');
          }
          
        }
      }

      window.customElements.define(VideoPlayer.is, VideoPlayer);
    })();
  </script>
</dom-module>
