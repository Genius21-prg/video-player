<link rel="import" href="../bower_components/imd/imd.html">
<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-repeat.html">

<link rel="import" href="3rd-imports/hls-js.html">
<link rel="import" href="3rd-imports/font-awesome.html">
<link rel="import" href="services/state-manager.html">
<link rel="import" href="components/video-stream.html">
<link rel="import" href="components/chapters-overview.html">
<link rel="import" href="components/control-bar/control-bar.html">

<dom-module id="video-player">
  <template>
    <style type="text/css">
      :host {
        display: inline-block;
      }

      /* For some reason, just chaining those fullscreen selectors into one big
         selector doesn't work so we're stupid-duplicating all the rules. */
      #video-player-container:-webkit-full-screen #streams-container{
        display: flex;
        align-items: center;
      }
      #video-player-container:-moz-full-screen #streams-container{
        display: flex;
        align-items: center;
      }
      #video-player-container:-ms-fullscreen #streams-container{
        display: flex;
        align-items: center;
      }

      #video-player-container {
        height: 100%;
      }
      #streams-container {
        display: flex;
        flex-wrap: wrap;
        overflow: hidden;
        /* Cancel out the control bar height */
        height: calc(100% - 45px);
      }
      .video-stream {
        flex: 1 1 50%;
      }
    </style>

    <div id="video-player-container">
      <div id="streams-container">
        <template is="dom-repeat" items="{{configuration.streams}}">
          <video-stream
            state="{{state}}"
            state-manager="{{stateManager}}"
            urls="{{item}}"
            master="{{_equals(index, 0)}}"
            class="video-stream"
            style$="height: calc(100% / {{_rowCount(configuration.streams)}});">
          </video-stream>
        </template>
      </div>
      <control-bar
        state="{{state}}"
        state-manager="{{stateManager}}"
        has-outline="{{_hasOutline()}}"
        available-qualities="{{availableQualities}}">
      </control-bar>
      <template is="dom-if" if="{{_hasOutline()}}">
        <chapters-overview
          class="invisible"
          state="{{state}}"
          state-manager="{{stateManager}}"
          outline="{{configuration.outline}}">
        </chapters-overview>
      </template>
    </div>
  </template>

  <script>
    define(['constants', 'state-manager', 'hls-js'], (constants, StateManager, Hls) => {
      const {DEFAULT_STATE, DEFAULT_CONFIGURATION, QUALITY_MODES} = constants;

      class VideoPlayer extends Polymer.Element {
        static get is() { return 'video-player'; }

        static get properties() {
          return {
            configuration: {
              type: Object,
              value: DEFAULT_CONFIGURATION,
            },
            state: {
              type: Object,
              value: DEFAULT_STATE,
            },
            stateManager: Object,
            availableQualities: {
              type: Array,
              computed: '_availableQualities(configuration.streams)',
            },
          };
        }

        static get observers() {
          return [
            '_fullScreenChanged(state.fullScreen)',
            '_displayChaptersOverviewChanged(state.displayChaptersOverview)',
          ];
        }

        ready() {
          super.ready();

          // Fill missing properties in provided state and configuration with default values
          this.configuration = Object.assign(DEFAULT_CONFIGURATION, this.configuration);
          this.state = Object.assign(DEFAULT_STATE, this.state, this.configuration.initialState);

          // Initialize StateManager
          this.stateManager = new StateManager(this, 'state');

          // If not all streams are available in the specified quality, use default one that is available for all streams
          if(!this.availableQualities.includes(this.state.quality)) {
            let defaultQuality = Object.values(QUALITY_MODES)
                                       .find(quality => this.availableQualities.includes(quality));
            this.stateManager.setQuality(defaultQuality);
          }

          // Add event listeners for fullscreen
          let self = this;
          this.$['video-player-container'].addEventListener('fullscreenchange', () => {
            self.stateManager.setFullScreen(document.fullscreen);
          });
          this.$['video-player-container'].addEventListener('webkitfullscreenchange', () => {
            self.stateManager.setFullScreen(document.webkitIsFullScreen);
          });
          // Firefox for some reason needs to attach the event to document
          document.addEventListener('mozfullscreenchange', () => {
            self.stateManager.setFullScreen(document.mozFullScreen);
          });
          this.$['video-player-container'].addEventListener('msfullscreenchange', () => {
            self.stateManager.setFullScreen(document.msFullscreenElement);
          });

          this._setCssVariables();
        }

        _fullScreenChanged(fullScreen) {
          if (fullScreen) {
            if (this.$['video-player-container'].requestFullscreen) this.$['video-player-container'].requestFullscreen();
            else if (this.$['video-player-container'].mozRequestFullScreen) this.$['video-player-container'].mozRequestFullScreen();
            else if (this.$['video-player-container'].webkitRequestFullScreen) this.$['video-player-container'].webkitRequestFullScreen();
            else if (this.$['video-player-container'].msRequestFullscreen) this.$['video-player-container'].msRequestFullscreen();
          } else {
            if (document.exitFullscreen) document.exitFullscreen();
            else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
            else if (document.webkitCancelFullScreen) document.webkitCancelFullScreen();
            else if (document.msExitFullscreen) document.msExitFullscreen();
          }
        }

        _availableQualities(streams) {
          let supportedQualities = Object.values(QUALITY_MODES);
          if(!Hls.isSupported()) {
            supportedQualities = supportedQualities.filter(quality => quality !== QUALITY_MODES.HLS);
          }

          return supportedQualities
                   .filter(quality => streams.every(stream => Object.keys(stream)
                                                                    .includes(quality)));
        }

        _equals(a, b) {
          return a === b;
        }
        _rowCount(streams) {
          return Math.ceil(streams.length/2);
        }

        _displayChaptersOverviewChanged(displayState) {
          if(this._hasOutline()) {
            let chaptersOverview = this.shadowRoot.querySelector('chapters-overview');
            if (chaptersOverview) {
              if (displayState) {
                chaptersOverview.classList.remove('invisible');
              } else {
                chaptersOverview.classList.add('invisible');
              }
            }
          }
        }

        _hasOutline() {
          return this.configuration && this.configuration.outline && this.configuration.outline.length !== 0;
        }

        // Since Firefox does not support WebComponents and shadow DOMs, it is not possible to set this in the CSS part.
        // The poperties is not correctyl evaluated and thus the variable not set.
        _setCssVariables() {
          this.style.setProperty('--primary-color', [[this.configuration.primaryColor]]);
          this.style.setProperty('--secondary-color', [[this.configuration.secondaryColor]]);
          this.style.setProperty('--background-color-for-primary', [[this.configuration.backgoundColorForPrimary]]);
        }
      }

      window.customElements.define(VideoPlayer.is, VideoPlayer);
    });
  </script>
</dom-module>
