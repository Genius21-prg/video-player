<link rel="import" href="../bower_components/imd/imd.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-repeat.html">

<link rel="import" href="base-element.html">
<link rel="import" href="3rd-imports/hls-js.html">
<link rel="import" href="styling/mixins.html">
<link rel="import" href="styling/font-awesome.html">
<link rel="import" href="services/state-manager.html">
<link rel="import" href="services/fullscreen-manager.html">
<link rel="import" href="services/synchronization-manager.html">
<link rel="import" href="services/user-preferences-manager.html">
<link rel="import" href="components/video-stream.html">
<link rel="import" href="components/chapter-list.html">
<link rel="import" href="components/interactive-transcript.html">
<link rel="import" href="components/overlays/waiting-overlay.html">
<link rel="import" href="components/overlays/finished-overlay.html">
<link rel="import" href="components/overlays/captions-display.html">
<link rel="import" href="components/control-bar/control-bar.html">
<link rel="import" href="components/progress-container/video-progress.html">
<link rel="import" href="components/progress-container/lecture-slide-bar/lecture-slide-bar.html">
<link rel="import" href="components/resizer-control.html">

<dom-module id="video-player">
  <template>
    <style type="text/css">
      :host {
        display: inline-block;
        border: 1px solid grey;
        background-color: black;
      }

      /* For some reason, just chaining those fullscreen selectors into one big
         selector doesn't work so we're stupid-duplicating all the rules. */
      #video-player-container:-webkit-full-screen #streams-container{
        display: flex;
        align-items: stretch;
      }
      #video-player-container:-moz-full-screen #streams-container{
        display: flex;
        align-items: stretch;
      }
      #video-player-container:-ms-fullscreen #streams-container{
        display: flex;
        align-items: stretch;
      }

      #video-player-container:-webkit-full-screen{
        width: 100%;
      }
      #video-player-container:-moz-full-screen{
        width: 100%;
      }
      #video-player-container:-ms-fullscreen{
        width: 100%;
      }

      #video-player-container {
        position: relative;
        height: 100%;
      }
      #video-player-container.fake-fullscreen {
        /* Actually, what we would want here is to set the height to 100vh...but
           in mobile browsers this results in the content being bigger than what
           the browser is able to display so we have to use 100% instead.
           For more information, see https://nicolas-hoizey.com/2015/02/viewport-height-is-taller-than-the-visible-part-of-the-document-in-some-mobile-browsers.html */
        width: 100vw;
        position: absolute;
        left: 0;
        top: 0;
      }

      #video-container {
        position: relative;
      }

      #streams-container {
        display: flex;
        flex-wrap: wrap;
        overflow: hidden;
        /* Cancel out the control bar height, the progress bar and the lecture slide bar */
        height: calc(100% - 40px - 16px - 11px);
      }
      .video-stream {
        /* 49 to leave a bit space for the resizer */
        flex: 1 1 49%;
      }

      #progress-container {
        border-top: 1px solid black;
        border-bottom: 1px solid black;
      }
    </style>

    <div id="video-player-container">
      <div id="video-container">
        <!-- Videos Overlays -->
        <waiting-overlay state="{{state}}" state-manager="{{stateManager}}"></waiting-overlay>
        <template is="dom-if" if="{{configuration.relatedVideos}}">
          <finished-overlay state="{{state}}" state-manager="{{stateManager}}" related-videos="{{configuration.relatedVideos}}"></finished-overlay>
        </template>

        <!-- Video Streams -->
        <div id="streams-container">
          <template is="dom-repeat" items="{{configuration.streams}}">
            <video-stream
              state="{{state}}"
              state-manager="{{stateManager}}"
              synchronization-manager="{{synchronizationManager}}"
              urls="{{item}}"
              preload="{{configuration.videoPreload}}"
              master="{{equals(index, 0)}}"
              class="video-stream"
              captions="{{configuration.captions}}"
              style$="height: calc(100% / {{rowCount(configuration.streams)}});">
            </video-stream>
            <template is="dom-if" if="{{needResizer(index, configuration.streams.length)}}">
              <resizer-control state="{{state}}" style$="visibility: [[ifThenElse(isResizerShown, 'visible', 'hidden')]]"></resizer-control>
            </template>
          </template>
        </div>
        <captions-display state="{{state}}" state-manager="{{stateManager}}"></captions-display>
      </div>

      <!-- Progress Bars -->
      <div id="progress-container">
        <template is="dom-if" if="{{configuration.lectureSlides}}">
          <lecture-slide-bar state="{{state}}" state-manager="{{stateManager}}" slides="{{configuration.lectureSlides}}"></lecture-slide-bar>
        </template>
        <video-progress state="{{state}}" state-manager="{{stateManager}}"></video-progress>
      </div>

      <!-- Control Bar -->
      <control-bar
        state="{{state}}"
        state-manager="{{stateManager}}"
        has-chapters="{{hasChapters}}"
        captions="{{configuration.captions}}"
        available-qualities="{{availableQualities}}">
      </control-bar>

      <!-- Chapter List -->
      <template is="dom-if" if="{{state.isChapterListShown}}">
        <chapter-list
          state="{{state}}"
          state-manager="{{stateManager}}"
          chapters="{{configuration.chapters}}">
        </chapter-list>
      </template>

      <interactive-transcript
        style$="display: [[ifThenElse(state.isInteractiveTranscriptShown, 'initial', 'none')]]"
        state="{{state}}"
        state-manager="{{stateManager}}">
      </interactive-transcript>

    </div>

  </template>

  <script>
    define(['base-element', 'state-manager', 'fullscreen-manager', 'synchronization-manager', 'user-preferences-manager', 'hls-js', 'constants'], (BaseElement, StateManager, FullscreenManager, SynchronizationManager, UserPreferencesManager, Hls, constants) => {
      const {DEFAULT_STATE, DEFAULT_CONFIGURATION, PLAY_STATES, QUALITY_MODES, PLAYING_EVENT_NAME} = constants;

      class VideoPlayer extends BaseElement {
        static get is() { return 'video-player'; }

        // A function is used to determine default values of properties to
        // ensure that each element gets its own copy of the value, rather than
        // having an object or array shared across all instances of the element.
        static get properties() {
          return {
            configuration: {
              type: Object,
              value: () => ({}),
            },
            state: {
              type: Object,
              value: () => ({}),
            },
            stateManager: Object,
            fullscreenManager: Object,
            synchronizationManager: Object,
            isResizerShown: {
              type: Boolean,
              value: false,
            },
            availableQualities: {
              type: Array,
              computed: '_availableQualities(configuration.streams)',
            },
            hasChapters: {
              type: Boolean,
              computed: '_hasChapters(configuration.chapters)',
            },
          };
        }

        static get observers() {
          return [
            'configurationChanged(configuration)',
            'availableQualitiesChanged(availableQualities, stateManager)',
            'foregroundColorChanged(configuration.foregroundColor)',
            'accentColorChanged(configuration.accentColor)',
            'backgroundColorChanged(configuration.backgroundColor)',
            'secondaryBackgroundColorChanged(configuration.secondaryBackgroundColor)',
            'playStateChanged(state.playState)',
            'fullscreenChanged(state.fullscreen)',
            'userPreferencesStateChanged(state.quality, state.playbackRate, state.volume)',
          ];
        }

        _availableQualities(streams) {
          if (streams) {
            let supportedQualities = Object.values(QUALITY_MODES);
            if(!Hls.isSupported()) {
              supportedQualities = supportedQualities.filter(quality => quality !== QUALITY_MODES.HLS);
            }

            return supportedQualities
                     .filter(quality => streams.every(stream => Object.keys(stream)
                                                                      .includes(quality)));
          }
        }

        _hasChapters() {
          return this.configuration && this.configuration.chapters && this.configuration.chapters.length !== 0;
        }

        ready() {
          super.ready();

          // Initialize UserPreferencesManager
          this.userPreferencesManager = new UserPreferencesManager();

          // Build state from provided intial state configuration and default values
          this.state = Object.assign({}, DEFAULT_STATE, this.state, this.configuration.initialState, this.userPreferencesManager.getPreferences());

          // Initialize StateManager
          this.stateManager = new StateManager(this, 'state');

          // Initialize FullscreenManager
          this.fullscreenManager = new FullscreenManager(this.$['video-player-container']);
          this.fullscreenManager.onFullscreenChanged((fullscreen) => {
            this.stateManager.setFullscreen(fullscreen);
          });

          // Initialize SynchronizationManager
          this.synchronizationManager = new SynchronizationManager(this.stateManager);

          // Add event handlers for mouse events to show/hide resizer
          this.$['streams-container'].addEventListener('mouseenter', () => this.isResizerShown = true);
          this.$['streams-container'].addEventListener('mouseleave', () => this.isResizerShown = false);

          // Listen for events from other instances to pause playback when
          // another instance starts playing
          window.addEventListener(PLAYING_EVENT_NAME, (e) => {
            if(e.detail && e.detail.sender !== this) {
              this.stateManager.pause();
            }
          });
        }

        reloadConfiguration() {
          // Clone configuration to reevaluate all observers
          this.configuration = Object.assign({}, this.configuration);
        }

        configurationChanged(configuration) {
          // Fill missing properties in provided configuration with default values
          if(Object.keys(DEFAULT_CONFIGURATION).filter(x => !Object.keys(configuration).includes(x)).length > 0) {
            this.configuration = Object.assign({}, DEFAULT_CONFIGURATION, configuration);
          }
        }

        availableQualitiesChanged(availableQualities) {
          // If not all streams are available in the specified quality, use default one that is available for all streams
          if(this.stateManager && !availableQualities.includes(this.state.quality)) {
            let defaultQuality = Object.values(QUALITY_MODES)
                                       .find(quality => availableQualities.includes(quality));
            this.stateManager.setQuality(defaultQuality);
          }
        }

        playStateChanged(playState) {
          // Dispatch event if video is playing to stop playback on other instances
          if(playState === PLAY_STATES.PLAYING) {
            let event = new CustomEvent(PLAYING_EVENT_NAME, {
              detail: {
                sender: this,
              },
            });

            window.dispatchEvent(event);
          }
        }

        fullscreenChanged(fullscreen) {
          if(this.fullscreenManager) {
            if (fullscreen) {
              this.fullscreenManager.enterFullscreen();
            } else {
              this.fullscreenManager.exitFullscreen();
            }
          }
        }

        rowCount(streams) {
          return Math.ceil(streams.length/2);
        }

        // Since Firefox does not support WebComponents and shadow DOMs, it is not possible to set this in the CSS part.
        // The properties are not correctly evaluated and thus the variable not set.
        foregroundColorChanged(color) {
          Polymer.updateStyles({'--foreground-color': color});
        }
        accentColorChanged(color) {
          Polymer.updateStyles({'--accent-color': color});
        }
        backgroundColorChanged(color) {
          Polymer.updateStyles({'--background-color': color});
        }
        secondaryBackgroundColorChanged(color) {
          Polymer.updateStyles({'--secondary-background-color': color});
        }

        userPreferencesStateChanged(quality, playbackRate, volume) {
          if (this.userPreferencesManager) {
            this.userPreferencesManager.setPreferences({
              quality,
              playbackRate,
              volume,
            });
          }
        }

        needResizer(index, length) {
          // Do not show the resizer when there is no second video to resize
          return (index % 2 === 0) && (index !== length - 1);
        }

        rowCount(streams) {
          return Math.ceil(streams.length / 2);
        }
      }

      window.customElements.define(VideoPlayer.is, VideoPlayer);
    });
  </script>
</dom-module>
